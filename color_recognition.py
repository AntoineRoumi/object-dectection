import csv
import math
import operator
import numpy as np
import os
import cv2

def color_histogram_of_image(image: np.ndarray) -> str:
    """Calculates the color histogram of an image.

    image: image represented as an numpy array of pixels 

    Returns a string containing the 3 color values of the histogram ("R,G,B")."""

    chans = cv2.split(image)
    colors = ('b', 'g', 'r')
    features = []
    feature_data = ''
    counter = 0
    red, green, blue = '', '', ''
    for (chan, _) in zip(chans, colors):
        counter = counter + 1

        hist = cv2.calcHist([chan], [0], None, [256], [0, 256])
        features.extend(hist)

        # find the peak pixel values for R, G, and B
        elem = np.argmax(hist)

        if counter == 1:
            blue = str(elem)
        elif counter == 2:
            green = str(elem)
        elif counter == 3:
            red = str(elem)
            feature_data = red + ',' + green + ',' + blue

    return feature_data


def color_histogram_of_training_image(img_name: str, data_source: str) -> str:
    """Calculates the histogram of a train image.

    img_name: name of the image file 
    data_source: name of the color of the image 

    Returns a string containing the 3 colors values of the histogram ("R,G,B,data_source")."""

    image = np.array(cv2.imread(img_name), dtype=np.uint8)

    feature_data = color_histogram_of_image(image)

    return f'{feature_data},{data_source}\n'


def training(training_dataset_dir: str, training_file_name: str) -> None:
    """Trains the color recognition model on a color dataset, and saves it.

    training_dataset_dir: directory containing the color dataset
    training_file_name: name of the training save file 
    
    ---

    Structure of the dataset directory:

    dataset
    ├─ red
    │  ├─ red1.jpg
    │  ├─ red2.jpg
    │  ...
    ├─ blue
    │  ├─ blue1.jpg
    │  ├─ blue2.jpg
    │  ...
    ..."""

    lines = []
    with os.scandir(training_dataset_dir) as color_dirs:
        for color_dirs_entry in color_dirs:
            if not color_dirs_entry.is_dir():
                continue

            with os.scandir(f'{training_dataset_dir}/{color_dirs_entry.name}') as color_dir:
                for color_dir_entry in color_dir:
                    if not color_dir_entry.is_file():
                        continue
                
                    lines.append(color_histogram_of_training_image(f'{training_dataset_dir}/{color_dirs_entry.name}/{color_dir_entry.name}', color_dirs_entry.name))

    with open(training_file_name, 'w') as training_file_file:
        training_file_file.write(''.join(lines))

# calculation of euclidead distance
def calculate_euclidean_distance(variable1, variable2, length) -> float:
    """Calculates the euclidian distance between two vectors.

    variable1: first vector, represented as an iterable
    variable2: second vector, represented as an iterable
    length: number of elements in the vectors

    Returns the euclidian distance."""
    distance = 0
    for x in range(length):
        distance += pow(variable1[x] - variable2[x], 2)
    return math.sqrt(distance)

class KnnClassifier:
    """Class used classify images by their color, calculated using the k-nearest neighbors method."""

    def __init__(self, training_data: str) -> None:
        self.training_feature_vector = []
        self.test_feature_vector = []
        self.load_training_dataset(training_data)

    def load_training_dataset(self, training_data: str) -> None:
        """Loads the given training dataset file.

        training_data: name of the training dataset file

        The training dataset file is a csv file that has to be generated by the training() function."""

        self.training_data = training_data
        with open(self.training_data) as csvfile:
            lines = csv.reader(csvfile)
            dataset: list[list[str | float]] = list(lines) # pyright: ignore
            for x in range(len(dataset)):
                for y in range(3):
                    dataset[x][y] = float(dataset[x][y])
                self.training_feature_vector.append(dataset[x])

    def __load_test_dataset(self, test_data: str) -> None:
        """Loads the given test dataset.
        This method shouldn't be used as such, use the predict() method instead.

        test_data: csv file content containig the color histogram of the test image ("R,G,B")

        The test data should be generated using the color_histogram_of_image() function."""

        self.test_feature_vector = []
        lines = csv.reader([test_data])
        dataset = list(lines)
        f_dataset = np.empty((len(dataset), 3), dtype=float)
        for x in range(len(dataset)):
            for y in range(3):
                f_dataset[x][y] = float(dataset[x][y])
            self.test_feature_vector.append(f_dataset[x].tolist())

    def predict(self, histogram: str) -> str:
        """Predicts the color of the given color histogram, using k-nearest neighbors.

        histogram: the color histogram of the test image ("R,G,B")

        The color histogram should be generated using the color_histogram_of_image() function."""
        classifier_prediction = []
        k = 3
        self.__load_test_dataset(histogram)
        for x in range(len(self.test_feature_vector)):
            print('->', self.test_feature_vector[x])
            neighbors = self.k_nearest_neighbors(self.test_feature_vector[x], k)
            print('-->', neighbors)
            result = self.response_of_neighbors(neighbors)
            classifier_prediction.append(result)
        return classifier_prediction[0]

    def k_nearest_neighbors(self, test_instance: list[float], k: int) -> list[float]:
        """Gets the k nearest neighbors of a test instance among the possible neighbors in the training dataset.

        test_instance: list containing the RGB values of the color histogram of the instance 
        k: number of neighbors to take in consideration (as defined for the k-nearest neighbors method)

        Returns a list of the k nearest neighbors to the instance in the training dataset"""
        distances = []
        length = len(test_instance)
        for x in range(len(self.training_feature_vector)):
            dist = calculate_euclidean_distance(test_instance,
                    self.training_feature_vector[x], length)
            distances.append((self.training_feature_vector[x], dist))
        distances.sort(key=operator.itemgetter(1))
        neighbors = []
        for x in range(k):
            neighbors.append(distances[x][0])
        return neighbors

    def response_of_neighbors(self, neighbors: list) -> str:
        """Proceeds a vote of the neighbors to determines the closest color to the instance.

        neighbors: list of all the neighbors of the instance

        Returns the name of the closest color."""
        all_possible_neighbors = {}
        for x in range(len(neighbors)):
            response = neighbors[x][-1]
            if response in all_possible_neighbors:
                all_possible_neighbors[response] += 1
            else:
                all_possible_neighbors[response] = 1
        sortedVotes = sorted(all_possible_neighbors.items(),
                             key=operator.itemgetter(1), reverse=True)
        return sortedVotes[0][0]
